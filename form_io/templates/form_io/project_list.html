{% extends "form_io/base.html" %}
{% block title %}Your Projects{% endblock %}

{% block main %}


<!-- Header + Button -->
<div class="flex items-center justify-between px-6 pt-6">
  <h1 class="text-3xl font-extrathin text-base-content font-serif tracking-wide">Your Projects</h1>
  <button class="btn btn-neutral btn-outline font-mono m-0" onclick="createProjectModal.showModal()">+ New Project</button>
</div>

<!-- Scrollable Card Container -->
<div class="h-[calc(80vh-8rem)] overflow-y-auto px-6 py-6 mt-4 mb-6 bg-base-100">
  <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6">
    {% for project in projects %}
    <div class="relative rounded-xl bg-base-100  hover:shadow-sm p-2 transition-transform hover:scale-[1.02]"
        style="background-color: {{ project.color }};">

      <!-- Dropdown Menu (Top-Right, DaisyUI Standard) -->
      <div class="absolute top-0 right-0 z-50 dropdown dropdown-start">
        <div tabindex="0" role="button" class="btn btn-xs btn-circle btn-ghost">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M6 12h.01M12 12h.01M18 12h.01"/>
          </svg>
        </div>
        <ul tabindex="0" class="dropdown-content menu bg-base-100 rounded-box shadow w-28 text-xs">
          <!-- Delete -->
        <li>
          <form method="POST" action="{% url 'delete_project' project.id %}">
            {% csrf_token %}
            <button class="text-red-500 w-full text-left">Delete</button>
          </form>
        </li>

          <!-- Duplicate -->
          <li><button>Duplicate</button></li>
          <!-- Rename -->
          <li><button>Rename</button></li>
        </ul>
      </div>


      <!-- Card Content -->
      <a href="{% url 'project_detail' project.id %}" class="block text-black p-2">
        <div class="flex flex-col justify-between h-full min-h-[120px]">
          <div>
<h2 class="text-2xl font-extralight font-sans w-full block truncate capitalize" title="{{ project.name }}">
  {{ project.name|slice:":16" }}{% if project.name|length > 18 %}…{% endif %}
</h2>


            <p class="text-sm font-thin mt-1 font-sans">{{ project.type|capfirst }}</p>
          </div>
          <p class="text-xs text-gray-700 mt-4">Last edited: {{ project.created_at|date:"Y-m-d H:i" }}</p>
        </div>
      </a>
    </div>
    {% empty %}
      <p class="text-gray-500 col-span-full">No projects yet. Create one above!</p>
    {% endfor %}
  </div>
</div>

<!-- Modal -->
<dialog id="createProjectModal" class="modal">
  
  <!-- Step 1: Modal Box with Padding and Max Width -->
  <div id="modal-step-1" class="modal-box bg-base-100 text-base-content w-full max-w-6xl relative p-6 rounded-lg">

    <!-- Header -->
    <div class="flex items-center justify-between mb-6">
      <div class="w-1/6"></div>
      <div class="w-4/6 text-center">
        <h3 class="text-xl font-thin">Create New Project</h3>
      </div>
      <div class="w-1/6 flex justify-end">
        <button class="btn btn-sm btn-circle btn-ghost" onclick="createProjectModal.close()">✕</button>
      </div>
    </div>

    <!-- Form Inputs -->
    <div class="form-control mb-4">
      <label class="label">Project Name</label>
      <input type="text" id="newProjectName" class="input input-bordered" required />
    </div>

    <div class="form-control mb-4">
      <label class="label">Project Type</label>
      <select id="newProjectType" class="select select-bordered">
        <option value="residential">Residential Project</option>
        <option value="acoustic">Acoustic Project</option>
        <option value="urban">Urban Planning Project</option>
      </select>
    </div>

    <div class="flex justify-end">
      <button class="btn btn-accent" onclick="nextModalStep()">Next</button>
    </div>
  </div>

  <!-- Step 2: Fullscreen Width/Height -->
  <div id="modal-step-2" style="display: none;" class="bg-base-100 text-base-content w-[80vw] h-[80vh] relative overflow-hidden">
    
    <!-- Header -->
    <div class="flex items-center justify-between px-6 pt-6 pb-2">
      <div>
        <button id="backBtn" class="btn btn-circle btn-outline btn-sm" onclick="backModalStep()">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>
      </div>
      <div class="text-center grow">
        <h3 class="text-xl font-thin">Select Location</h3>
      </div>
      <div class="flex justify-end">
        <button class="btn btn-sm btn-circle btn-ghost" onclick="createProjectModal.close()">✕</button>
      </div>
    </div>

    <!-- Map + Button -->
    <div class="h-[calc(75vh-6rem)] px-6 pb-6">
     
<div class="text-xs text-gray-500 px-6 pt-2 font-thin">
  Click the first point again to finish drawing site boundary.
</div>

      <div id="map" class="w-full h-full border rounded-md"></div>

      <div class="flex justify-end mt-4">
        <button class="btn btn-primary" onclick="submitNewProject()">Create</button>
      </div>
    </div>
  </div>

</dialog>


<!-- JavaScript to Toggle Modal Padding -->
<script>
function nextModalStep() {
  document.getElementById("modal-step-1").style.display = "none";
  document.getElementById("modal-step-2").style.display = "block";
  initializeMap();
}

function backModalStep() {
  document.getElementById("modal-step-2").style.display = "none";
  document.getElementById("modal-step-1").style.display = "block";
}

document.addEventListener("DOMContentLoaded", () => {
  document.getElementById("backBtn").classList.remove("hidden");
});

// Optional: Ensure backBtn is hidden on open
document.addEventListener("DOMContentLoaded", () => {
  document.getElementById("backBtn").classList.add("hidden");
});

</script>





<script>
  mapboxgl.accessToken = '{{ mapbox_token }}';

  let map, draw;
  let labelMarkers = [];

  function initializeMap() {
    if (map) return;

    map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [13.405, 52.52],
      zoom: 16,
      pitch: 60,
      bearing: -17.6,
      antialias: true
    });

    draw = new MapboxDraw({
      displayControlsDefault: false,
      controls: {
        polygon: true,
        trash: true
      }
    });

    map.addControl(draw);

    let gridAdded = false;

    map.on('draw.modechange', (e) => {
      if (e.mode === 'draw_polygon') {
        map.once('click', (event) => {
          const startLngLat = [event.lngLat.lng, event.lngLat.lat];
          const bounds = createBoundsAround(startLngLat, 0.002); // ~200m buffer
          const grid = generateGrid(bounds, 0.0001); // ~10m spacing
          if (!map.getSource('grid-lines')) {
            map.addSource('grid-lines', { type: 'geojson', data: grid });
            map.addLayer({
              id: 'grid-lines-layer',
              type: 'line',
              source: 'grid-lines',
              paint: {
                'line-color': '#ccc',
                'line-width': 0.5
              }
            });
          } else {
            map.getSource('grid-lines').setData(grid);
          }
          gridAdded = true;
        });
      } else if (gridAdded) {
        map.removeLayer('grid-lines-layer');
        map.removeSource('grid-lines');
        gridAdded = false;
      }
    });

    // helper
    function createBoundsAround(center, buffer) {
      const [lng, lat] = center;
      return [lng - buffer, lat - buffer, lng + buffer, lat + buffer];
    }

function snapToGrid(coord, gridSize = 0.0001) {
  const snappedLng = Math.round(coord[0] / gridSize) * gridSize;
  const snappedLat = Math.round(coord[1] / gridSize) * gridSize;
  return [snappedLng, snappedLat];
}

function createBoundsAround(center, buffer) {
  const [lng, lat] = center;
  return [lng - buffer, lat - buffer, lng + buffer, lat + buffer];
}

function generateGrid(bounds, spacing = 0.0001) {
  const features = [];
  const [minLng, minLat, maxLng, maxLat] = bounds;

  for (let lng = minLng; lng < maxLng; lng += spacing) {
    features.push(turf.lineString([[lng, minLat], [lng, maxLat]]));
  }
  for (let lat = minLat; lat < maxLat; lat += spacing) {
    features.push(turf.lineString([[minLng, lat], [maxLng, lat]]));
  }
  return turf.featureCollection(features);
}

const SnapPolygon = MapboxDraw.modes.draw_polygon;

const DrawPolygonSnap = {
  ...SnapPolygon,
  clickAnywhere(state, e) {
    e.lngLat = {
      lng: snapToGrid([e.lngLat.lng], 0.0001)[0],
      lat: snapToGrid([e.lngLat.lat], 0.0001)[1]
    };
    return SnapPolygon.clickAnywhere.call(this, state, e);
  },
  onMouseMove(state, e) {
    const snapped = snapToGrid([e.lngLat.lng, e.lngLat.lat], 0.0001);
    e.lngLat = { lng: snapped[0], lat: snapped[1] };
    return SnapPolygon.onMouseMove.call(this, state, e);
  }
};



    map.on('draw.update', (e) => {
      const feature = e.features[0];
      if (feature.geometry.type === 'Polygon') {
        feature.geometry.coordinates[0] = feature.geometry.coordinates[0].map(coord =>
          snapToGrid(coord, 0.0001)
        );
        draw.delete(feature.id);
        draw.add(feature);
      }
    });


    map.on('load', () => {
      
      map.addLayer({
        id: '3d-buildings',
        source: 'composite',
        'source-layer': 'building',
        filter: ['==', 'extrude', 'true'],
        type: 'fill-extrusion',
        minzoom: 15,
        paint: {
          'fill-extrusion-color': '#aaa',
          'fill-extrusion-height': ['get', 'height'],
          'fill-extrusion-base': ['get', 'min_height'],
          'fill-extrusion-opacity': 0.6
        }
      });
    });

    const geocoder = new MapboxGeocoder({
      accessToken: mapboxgl.accessToken,
      mapboxgl: mapboxgl,
      marker: false,
      placeholder: 'Search location...'
    });
    map.addControl(geocoder, 'top-left');

    geocoder.on('result', (e) => {
      const [lng, lat] = e.result.center;
      map.flyTo({ center: [lng, lat], zoom: 16 });
    });

        // On draw complete
    map.on('draw.create', (e) => {
      updateEdgeLabels();
    });


        map.on('draw.update', updateEdgeLabels);
        map.on('draw.selectionchange', updateEdgeLabels);
        map.on('draw.delete', clearEdgeLabels);
      }


  function updateEdgeLabels() {
    clearEdgeLabels();

    const data = draw.getAll();
    if (!data.features.length) return;

    const feature = data.features[0];
    if (!feature.geometry || feature.geometry.type !== 'Polygon') return;

    const coords = feature.geometry.coordinates[0];

    for (let i = 0; i < coords.length - 1; i++) {
      const p1 = coords[i];
      const p2 = coords[i + 1];

      const dist = turf.distance(turf.point(p1), turf.point(p2), { units: 'meters' });
      const midLng = (p1[0] + p2[0]) / 2;
      const midLat = (p1[1] + p2[1]) / 2;

      const el = document.createElement('div');
      el.className = 'dimension-label';
      el.innerText = `${dist.toFixed(1)} m`;
      styleLabel(el);

      const marker = new mapboxgl.Marker(el)
        .setLngLat([midLng, midLat])
        .addTo(map);

      labelMarkers.push(marker);
    }

    const area = turf.area(feature);
    const areaText = area >= 10000
      ? `${(area / 10000).toFixed(2)} ha`
      : `${area.toFixed(1)} m²`;

    const center = turf.centroid(feature).geometry.coordinates;

    const areaEl = document.createElement('div');
    areaEl.className = 'dimension-label';
    areaEl.innerText = `Area: ${areaText}`;
    styleLabel(areaEl);

    const areaMarker = new mapboxgl.Marker(areaEl)
      .setLngLat(center)
      .addTo(map);

    labelMarkers.push(areaMarker);
  }

  function styleLabel(el) {
    el.style.padding = '2px 6px';
    el.style.background = 'white';
    el.style.borderRadius = '4px';
    el.style.fontSize = '12px';
    el.style.border = '1px solid #ccc';
    el.style.boxShadow = '0 0 2px rgba(0, 0, 0, 0.2)';
    el.style.pointerEvents = 'none';
  }

  function clearEdgeLabels() {
    labelMarkers.forEach(marker => marker.remove());
    labelMarkers = [];
  }

  async function submitNewProject() {
    const name = document.getElementById('newProjectName').value;
    const type = document.getElementById('newProjectType').value;
    const features = draw.getAll();

    if (!features || features.features.length === 0) {
      alert("Please draw a site boundary.");
      return;
    }

    const csrfToken = getCSRFToken();

    try {
      const response = await fetch('/api/projects/create/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': csrfToken,
        },
        body: JSON.stringify({
          name: name,
          type: type,
          location: '',
          site_geometry: features
        })
      });

if (response.ok) {
  const data = await response.json();
  window.location.href = `/projects/${data.project_id}/`;
} else {
  const data = await response.json();
  alert("Error: " + data.error);
}

    } catch (e) {
      console.error("Project creation failed:", e);
    }
  }

  function getCSRFToken() {
    const name = 'csrftoken';
    const cookieValue = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
    return cookieValue ? cookieValue.pop() : '';
  }



</script>



{% endblock %}
